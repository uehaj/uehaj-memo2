{"componentChunkName":"component---src-templates-blog-template-js","path":"/60abb9be0dfac0755dcf","result":{"data":{"site":{"siteMetadata":{"title":"Delog"}},"markdownRemark":{"html":"<p><a href=\"http://atnd.org/events/41603\">第13回 オフラインリアルタイムどう書く</a>の問題「<a href=\"http://nabetani.sakura.ne.jp/hena/ord13blocktup/\">積み木の水槽</a>」を、JVM上で動作するHaskellライクな言語<a href=\"https://github.com/Frege/frege/wiki/_pages\">Frege</a>(フレーゲ)で解きました。</p>\n<div class=\"gatsby-highlight\" data-language=\"frege:shortest.fr\"><pre class=\"language-frege:shortest.fr\"><code class=\"language-frege:shortest.fr\">-- http://nabetani.sakura.ne.jp/hena/ord13blocktup/\n     \ndata Cell = Wall | Empty | Water\nderive Eq Cell -- Haskellのdata Cell = ... deriving(Eq)\n\n-- セルを表示する\ninstance Show Cell where\n    show Wall = &quot;*&quot;\n    show Empty = &quot; &quot;\n    show Water = &quot;+&quot;\n\n-- 盤面を表示する\ndata Matrix = Matrix [ [ Cell ] ] Int Int\nderive Eq Matrix\ninstance Show Matrix where\n    show (Matrix xs w h) = &quot;w=&quot;++show w++&quot;,h=&quot;++show h++&quot;\\n&quot;++ unlines (map showLine xs)\n        where\n          showLine :: [Cell] -&gt; String\n          showLine line = &quot;[&quot; ++ foldl (++) &quot;&quot; (map show line) ++ &quot;]&quot;\n\n-- 盤面を生成する\ntoMatrix :: String -&gt; Matrix\ntoMatrix str =\n    let maxx = length str\n        maxy = maximum $ map (\\ch -&gt; ord ch - ord &#39;0&#39;) (unpacked str)\n        makeLine n maxn = replicate n Wall ++ replicate (maxn-n) Empty\n    in Matrix (map (\\ch -&gt; makeLine (ord ch - ord &#39;0&#39;) maxy) (unpacked str)) maxx maxy\n\n-- 指定した座標(xPos,yPos)のセル内容を取得する\ngetCell :: Matrix -&gt; Int -&gt; Int -&gt; Cell\ngetCell (Matrix mat w h) xPos yPos\n      | (0 &lt;= xPos) &amp;&amp; ( xPos &lt; w ) &amp;&amp; (0 &lt;= yPos) &amp;&amp; (yPos &lt; h) = mat !! xPos !! yPos\n      | otherwise = Empty\n\n-- Matrix型の盤面の指定した座標(xPos,yPos)にセル内容cを設定する\nsetCell:: Matrix -&gt; Int -&gt; Int -&gt; Cell -&gt; Matrix\nsetCell (Matrix mat w h) xPos yPos c\n      | ( xPos &lt; w ) &amp;&amp; (yPos &lt; h) = Matrix (setCell&#39; mat xPos yPos c) w h\n\n-- [[Cell]]型の盤面の指定した座標(xPos,yPos)にセル内容cを設定する\nsetCell&#39; :: [[Cell]] -&gt; Int -&gt; Int -&gt; Cell -&gt; [[Cell]]\nsetCell&#39; (x:xs) xPos yPos c\n    | xPos == 0 = setCellY x yPos c : xs\n    | otherwise = x:setCell&#39; xs (xPos-1) yPos c\n\n-- Cellの列の指定した座標(yPos)にセル内容cを設定する\nsetCellY :: [Cell] -&gt; Int -&gt; Cell -&gt; [Cell]\nsetCellY (x:xs) yPos c\n    | yPos == 0 = c:xs\n    | otherwise = x:setCellY xs (yPos-1) c\n\n-- 以下のtmpは、以下が通らなかったための苦肉の策。fregeのバグ?\n-- fillWater m0 = foldl (\\mat (x,y)-&gt; fillWaterCell mat x y) m0 (cells m0)\ntmp:: Matrix -&gt; (Int, Int) -&gt; Matrix\ntmp mat (x,y) = fillWaterCell mat x y\n\n-- 盤面に水を満たす\nfillWater :: Matrix -&gt; Matrix\nfillWater m0 = foldl tmp m0 (cells m0)\n  where\n    cells (Matrix _ width height) = do\n        y &lt;- [0.. height-1]\n        x &lt;- [0.. width-1]\n        return (x, y)\n\nfillWaterCell mat x y\n    | isKeepWater mat x y &amp;&amp; getCell mat x y == Empty = setCell mat x y Water\n    | otherwise = mat\n\n-- 指定した座標x,yは水を保持できるか？\nisKeepWater :: Matrix -&gt; Int -&gt; Int -&gt; Bool\nisKeepWater mat x y\n    | hereOK mat x y = true\n    | leftOK mat x y &amp;&amp; bottomOK mat x y &amp;&amp; rightThroughOK mat x y = true\n    | otherwise = false\n    where\n        ok x = (x == Wall) || (x == Water)\n        hereOK mat x y = ok $ getCell mat x y\n        leftOK mat x y = ok $ getCell mat (x-1) y\n        bottomOK mat x y = ok $ getCell mat x (y-1)\n        rightOK mat x y = ok $ getCell mat (x+1) y\n        rightThroughOK mat x y\n            | bottomOK mat x y &amp;&amp; rightOK mat x y = true\n            | bottomOK mat x y &amp;&amp; rightThroughOK mat (x+1) y = true\n            | otherwise = false\n           \n-- 水の個数を返す\ncountAllWater :: Matrix -&gt; Int\ncountAllWater (Matrix m _ _) = foldr ((+) . countAllWaterY) 0 m\n    where\n        countAllWaterY [] = 0\n        countAllWaterY (Water:xs) = 1 + countAllWaterY xs\n        countAllWaterY (x:xs) = 0 + countAllWaterY xs\n\n-- x.atoiはHaskellのread xと等価(xがintとして解釈可能である文字列の場合)。\ntest :: String -&gt; String -&gt; Bool\ntest dat expected = expected.atoi == (countAllWater $ fillWater (toMatrix dat))\n\nmain :: [String] -&gt; IO ()\nmain _ = do\n   println $ test &quot;83141310145169154671122&quot; &quot;24&quot; {-0-}\n   println $ test &quot;923111128&quot; &quot;45&quot; {-1-}\n   println $ test &quot;923101128&quot; &quot;1&quot; {-2-}\n   println $ test &quot;903111128&quot; &quot;9&quot; {-3-}\n   println $ test &quot;3&quot; &quot;0&quot; {-4-}\n   println $ test &quot;31&quot; &quot;0&quot; {-5-}\n   println $ test &quot;412&quot; &quot;1&quot; {-6-}\n   println $ test &quot;3124&quot; &quot;3&quot; {-7-}\n   println $ test &quot;11111&quot; &quot;0&quot; {-8-}\n   println $ test &quot;222111&quot; &quot;0&quot; {-9-}\n   println $ test &quot;335544&quot; &quot;0&quot; {-10-}\n   println $ test &quot;1223455321&quot; &quot;0&quot; {-11-}\n   println $ test &quot;000&quot; &quot;0&quot; {-12-}\n   println $ test &quot;000100020003121&quot; &quot;1&quot; {-13-}\n   println $ test &quot;1213141516171819181716151413121&quot; &quot;56&quot; {-14-}\n   println $ test &quot;712131415161718191817161514131216&quot; &quot;117&quot; {-15-}\n   println $ test &quot;712131405161718191817161514031216&quot; &quot;64&quot; {-16-}\n   println $ test &quot;03205301204342100&quot; &quot;1&quot; {-17-}\n   println $ test &quot;0912830485711120342&quot; &quot;18&quot; {-18-}\n   println $ test &quot;1113241120998943327631001&quot; &quot;20&quot; {-19-}\n   println $ test &quot;7688167781598943035023813337019904732&quot; &quot;41&quot; {-20-}\n   println $ test &quot;2032075902729233234129146823006063388&quot; &quot;79&quot; {-21-}\n   println $ test &quot;8323636570846582397534533&quot; &quot;44&quot; {-22-}\n   println $ test &quot;2142555257761672319599209190604843&quot; &quot;41&quot; {-23-}\n   println $ test &quot;06424633785085474133925235&quot; &quot;51&quot; {-24-}\n   println $ test &quot;503144400846933212134&quot; &quot;21&quot; {-25-}\n   println $ test &quot;1204706243676306476295999864&quot; &quot;21&quot; {-26-}\n   println $ test &quot;050527640248767717738306306596466224&quot; &quot;29&quot; {-27-}\n   println $ test &quot;5926294098216193922825&quot; &quot;65&quot; {-28-}\n   println $ test &quot;655589141599534035&quot; &quot;29&quot; {-29-}\n   println $ test &quot;7411279689677738&quot; &quot;34&quot; {-30-}\n   println $ test &quot;268131111165754619136819109839402&quot; &quot;102&quot; {-31-}</code></pre></div>","frontmatter":{"date":"January 01, 1970","path":"/60abb9be0dfac0755dcf","title":"第13回オフラインリアルタイムどう書くの問題をFregeで解く","thumbnail":null,"metaDescription":null}}},"pageContext":{}}}