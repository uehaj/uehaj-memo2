{"componentChunkName":"component---src-templates-blog-template-js","path":"/https://qiita.com/uehaj/items/5f46b012f13e1d3cee55/index.html","result":{"data":{"site":{"siteMetadata":{"title":"Delog"}},"markdownRemark":{"html":"<p><a href=\"http://qiita.com/Nabetani/items/f3cca410428f90333e28\">第12回 オフラインリアルタイムどう書く</a>の問題「<a href=\"http://nabetani.sakura.ne.jp/hena/ord12rotdice/\">サイコロを転がす</a>」を、Haskellで解きました。\nStateモナド厨。</p>\n<div class=\"gatsby-highlight\" data-language=\"dicestate.hs\"><pre class=\"language-dicestate.hs\"><code class=\"language-dicestate.hs\">-- http://nabetani.sakura.ne.jp/hena/ord12rotdice/\nimport Data.List\nimport Control.Monad.State\n\n-- 1と2の向きで表わしたサイコロの方向の状態。NEは「1の目が北(N)、2の目が東(E)」を表わす。Uは上、Dは下を表わす。\ndata DiceState = NE|ES|SW|WN|EN|SE|WS|NW|UN|ND|DS|SU|NU|DN|SD|US|UE|ED|DW|WU|EU|DE|WD|UW deriving (Show, Eq)\n\n-- それぞれのサイコロの状態で上面の数字(目)を表わす連想リスト。\ndeuce :: [(DiceState, Char)]\ndeuce = [(NE,&#39;4&#39;),(ES,&#39;4&#39;),(SW,&#39;4&#39;),(WN,&#39;4&#39;),(EN,&#39;3&#39;),(SE,&#39;3&#39;),\n         (WS,&#39;3&#39;),(NW,&#39;3&#39;),(UN,&#39;1&#39;),(ND,&#39;5&#39;),(DS,&#39;6&#39;),(SU,&#39;2&#39;),\n         (NU,&#39;2&#39;),(DN,&#39;6&#39;),(SD,&#39;5&#39;),(US,&#39;1&#39;),(UE,&#39;1&#39;),(ED,&#39;5&#39;),\n         (DW,&#39;6&#39;),(WU,&#39;2&#39;),(EU,&#39;2&#39;),(DE,&#39;6&#39;),(WD,&#39;5&#39;),(UW,&#39;1&#39;)]\n\n-- ころがし操作。&#39;N&#39;:北へころがす, &#39;W&#39;:西へころがす, &#39;S&#39;:南へころがす, &#39;E&#39;:東へころがす\ntype Roll = Char\n\n-- サイコロの状態における目(上を向いている面の数値)を返す\ngetDeuce :: DiceState -&gt; Char\ngetDeuce state = let (Just n) = lookup state deuce in n\n\nmkpair :: (t, t, t, t) -&gt; [(t, t)]\nmkpair (a,b,c,d) = [(a,b),(b,c),(c,d),(d,a)]\n\n-- 東にころがす回転(&#39;E&#39;)におけるサイコロ状態の変化\n-- [(回転前の状態,回転後の状態), ...]の連想リスト\nmoveDataToEast :: [(DiceState, DiceState)]\nmoveDataToEast = concat [mkpair (UN,EN,DN,WN),\n                         mkpair (ND,NW,NU,NE),\n                         mkpair (DS,WS,US,ES),\n                         mkpair (SU,SE,SD,SW),\n                         mkpair (ED,DW,WU,UE),\n                         mkpair (EU,DE,WD,UW)]\n-- 北にころがす回転(&#39;N&#39;)におけるサイコロ状態の変化\n-- [(回転前の状態,回転後の状態), ...]の連想リスト\nmoveDataToNorth :: [(DiceState, DiceState)]\nmoveDataToNorth = concat [mkpair (UN,ND,DS,SU),\n                          mkpair (EN,ED,ES,EU),\n                          mkpair (DN,SD,US,NU),\n                          mkpair (WN,WD,WS,WU),\n                          mkpair (NW,DW,SW,UW),\n                          mkpair (SE,UE,NE,DE)]\n\n-- 指定した状態に対して、ころがし操作を与えたとき、次状態を得る\nstep :: Roll -&gt; DiceState -&gt; DiceState\nstep r direc = case r of\n                 &#39;N&#39; -&gt; moveN direc\n                 &#39;W&#39; -&gt; moveW direc\n                 &#39;S&#39; -&gt; moveS direc\n                 &#39;E&#39; -&gt; moveE direc\n               where\n                 -- 北にころがしたときの次状態を返す\n                 moveN :: DiceState -&gt; DiceState\n                 moveN s = let (Just d) = lookup s moveDataToNorth in d\n                 -- 西にころがしたときの次状態を返す\n                 moveW :: DiceState -&gt; DiceState\n                 moveW s = moveE $ moveE $ moveE s\n                 -- 南にころがしたときの次状態を返す\n                 moveS :: DiceState -&gt; DiceState\n                 moveS s = moveN $ moveN $ moveN s\n                 -- 東にころがしたときの次状態を返す\n                 moveE :: DiceState -&gt; DiceState\n                 moveE s = let (Just d) = lookup s moveDataToEast in d\n\n-- ころがし操作を与えると次の状態モナドを返すモナディック関数\n-- 状態は、(サイコロ上面の数値(目)の履歴, サイコロの状態)というタプルで表現。\nstepSt :: Roll -&gt; State (String, DiceState) ()\nstepSt ch = do\n  (xs, direc) &lt;- get\n  let nextDirec = step ch direc\n  state $ const ((), (getDeuce nextDirec:xs, nextDirec))\n\n-- ころがし操作の列と、結果(目の履歴)の期待値を与え、一致しているかどうかを返す\ntest :: String -&gt; String -&gt; Bool\ntest opr expected = let (xs, _) = execState (mapM stepSt opr) ([&#39;1&#39;], UN)\n                    in (reverse xs == expected)\n\nmain :: IO ()\nmain = do\n    print $ test &quot;NNESWWS&quot; &quot;15635624&quot;  {-- 0 --}\n    print $ test &quot;EEEE&quot; &quot;13641&quot;  {-- 1 --}\n    print $ test &quot;WWWW&quot; &quot;14631&quot;  {-- 2 --}\n    print $ test &quot;SSSS&quot; &quot;12651&quot;  {-- 3 --}\n    print $ test &quot;NNNN&quot; &quot;15621&quot;  {-- 4 --}\n    print $ test &quot;EENN&quot; &quot;13651&quot;  {-- 5 --}\n    print $ test &quot;WWNN&quot; &quot;14651&quot;  {-- 6 --}\n    print $ test &quot;SSNN&quot; &quot;12621&quot;  {-- 7 --}\n    print $ test &quot;NENNN&quot; &quot;153641&quot;  {-- 8 --}\n    print $ test &quot;NWNNN&quot; &quot;154631&quot;  {-- 9 --}\n    print $ test &quot;SWWWSNEEEN&quot; &quot;12453635421&quot;  {-- 10 --}\n    print $ test &quot;SENWSWSNSWE&quot; &quot;123123656545&quot;  {-- 11 --}\n    print $ test &quot;SSSWNNNE&quot; &quot;126546315&quot;  {-- 12 --}\n    print $ test &quot;SWNWSSSWWE&quot; &quot;12415423646&quot;  {-- 13 --}\n    print $ test &quot;ENNWWS&quot; &quot;1354135&quot;  {-- 14 --}\n    print $ test &quot;ESWNNW&quot; &quot;1321365&quot;  {-- 15 --}\n    print $ test &quot;NWSSE&quot; &quot;154135&quot;  {-- 16 --}\n    print $ test &quot;SWNWEWSEEN&quot; &quot;12415154135&quot;  {-- 17 --}\n    print $ test &quot;EWNWEEEEWN&quot; &quot;13154532426&quot;  {-- 18 --}\n    print $ test &quot;WNEWEWWWSNW&quot; &quot;145151562421&quot;  {-- 19 --}\n    print $ test &quot;NNEE&quot; &quot;15631&quot;  {-- 20 --}\n    print $ test &quot;EEEEWNWSW&quot; &quot;1364145642&quot;  {-- 21 --}\n    print $ test &quot;SENNWWES&quot; &quot;123142321&quot;  {-- 22 --}\n    print $ test &quot;SWWWSNSNESWW&quot; &quot;1245363635631&quot;  {-- 23 --}\n    print $ test &quot;WESSENSE&quot; &quot;141263231&quot;  {-- 24 --}\n    print $ test &quot;SWNSSESESSS&quot; &quot;124146231562&quot;  {-- 25 --}\n    print $ test &quot;ENS&quot; &quot;1353&quot;  {-- 26 --}\n    print $ test &quot;WNN&quot; &quot;1453&quot;  {-- 27 --}\n    print $ test &quot;SSEENEEEN&quot; &quot;1263124536&quot;  {-- 28 --}\n    print $ test &quot;NWSNNNW&quot; &quot;15414632&quot;  {-- 29 --}\n    print $ test &quot;ESSSSSWW&quot; &quot;132453215&quot;  {-- 30 --}\n    print $ test &quot;ESE&quot; &quot;1326&quot;  {-- 31 --}\n    print $ test &quot;SNWNWWNSSSS&quot; &quot;121456232453&quot;  {-- 32 --}\n    print $ test &quot;SWEESEN&quot; &quot;12423653&quot;  {-- 33 --}\n    print $ test &quot;NEEWNSSWWW&quot; &quot;15323631562&quot;  {-- 34 --}\n    print $ test &quot;WSEW&quot; &quot;14212&quot;  {-- 35 --}\n    print $ test &quot;SWSNNNSNWE&quot; &quot;12464131353&quot;  {-- 36 --}\n    print $ test &quot;ENWEWSEEW&quot; &quot;1351513545&quot;  {-- 37 --}\n    print $ test &quot;WSEWN&quot; &quot;142124&quot;  {-- 38 --}\n    print $ test &quot;EWNEESEWE&quot; &quot;1315321414&quot;  {-- 39 --}\n    print $ test &quot;NESEEN&quot; &quot;1531263&quot;  {-- 40 --}\n    print $ test &quot;WSW&quot; &quot;1426&quot;  {-- 41 --}\n    print $ test &quot;ENEWE&quot; &quot;135656&quot;  {-- 42 --}</code></pre></div>","frontmatter":{"date":"January 01, 1970","path":"/https://qiita.com/uehaj/items/5f46b012f13e1d3cee55/index.html","title":"第12回オフラインリアルタイムどう書くの問題「サイコロを転がす」をHaskellで解く","thumbnail":null,"metaDescription":null}}},"pageContext":{}}}