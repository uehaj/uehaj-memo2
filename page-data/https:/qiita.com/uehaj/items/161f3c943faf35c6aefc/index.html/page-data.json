{"componentChunkName":"component---src-templates-blog-template-js","path":"/https://qiita.com/uehaj/items/161f3c943faf35c6aefc/index.html","result":{"data":{"site":{"siteMetadata":{"title":"Delog"}},"markdownRemark":{"html":"<p><a href=\"http://www.amazon.co.jp/exec/obidos/ASIN/4274069117/uehaj-22/ref=nosim/\">TAPL本(Types And Programming Language、型システム入門)</a>の各章にある「ML実装」の例をRustにポーティングしてみるシリーズ、「7章のラムダ計算のML実装」です。<a href=\"http://qiita.com/uehaj/items/1ac71855d05132d54eb8\">4章の</a>に比べるといきなり難易度が上がります。全体からしたら序の口でしょうが。</p>\n<h1>説明</h1>\n<ul>\n<li>unstableなゲート化された機能<a href=\"https://doc.rust-lang.org/book/box-syntax-and-patterns.html\">box_patterns</a>を1箇所で使用しているので、Rust 1.0 betaではコンパイルできず、unstable機能がerrorにならないnightly版でしかコンパイルできません。趣旨からして、おそらく1.0 release版でも実行できないでしょう。でもこれを使わずに実装することができなかったのでやむなく。(<a href=\"https://github.com/rust-lang/rfcs/blob/master/text/0469-feature-gate-box-patterns.md\">参考</a>)</li>\n<li>以下でnamed.rsは、名無し項ではなく、通常の項を表現するものです。7章には指導がないが、名無し項への変換がないと余りに不便なので作りました。</li>\n<li>以下のようなλ計算が評価できます。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"rust\"><pre class=\"language-rust\"><code class=\"language-rust\">     <span class=\"token function\">println!</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"{:?}\"</span><span class=\"token punctuation\">,</span>\n             <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token function\">abst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">,</span> \n                         <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token function\">abst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">,</span>\n                                    <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">abst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"x\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                               <span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">abst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"z\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"a\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                               <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n                    <span class=\"token function\">abst</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"w\"</span><span class=\"token punctuation\">,</span> <span class=\"token function\">var</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"w\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n                    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">remove_names</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">eval</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 結果は(lambda w. w)</span></code></pre></div>\n<h1>気づいたことや工夫</h1>\n<ul>\n<li>Termのような再帰的データ構造を実現するために、enumでowned pointerを使用すると、Box::newが頻出したりして可読性が悪化するが、enumのデータ構築子をそのまま使うのではなく、以下のような、引数にTermを受けとってBox::newを実行した上でデータ構築を行うような、簡単なラッパーを作ると構築に関しては簡潔さを維持できる。ついでに&#x26;str→String変換しておく。欲を出すと、そういう関数群を自動的deriveしてくれるようなTraitがあればいいのに。 </li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fn abst(s:&amp;str, t:Term) -&gt; Term {\n    Abst(s.to_string(), Box::new(t))\n}\n\nfn apply(t1:Term, t2:Term) -&gt; Term {\n    Apply(Box::new(t1), Box::new(t2))\n}</code></pre></div>\n<ul>\n<li>de Bruijn Indexは、数学的証明との対応がしやすい以外のメリットはたぶんなく、本当のコンパイラの実装では導入しない種類のものと思われる。まあ変数名集合の集合操作でやるよりはプログラムっぽいが。</li>\n<li>何度も言うがrustのパターンマッチは難しい気がする。&#x26;,mut,ref,box,などがやっかいにしている。もっとドキュメントもしくは経験が必要だ。</li>\n<li>RustではHaskellやMLのように入れ子になった関数で親をアクセスするものは定義できないらしい(<a href=\"http://stackoverflow.com/questions/26685666/a-local-function-in-rust\">参考</a>)。Closure使えばいいのだろうが、再帰呼び出しするClosureはきれいには定義できない(<a href=\"http://stackoverflow.com/questions/16946888/recursive-closure-in-rust\">参考</a>)。</li>\n<li>環境変数RUST<em>BACKTRACEを1にするとpanic!時などにスタックトレースが表示される。`<code class=\"language-text\"></code>env RUST</em>BACKTRACE=1 cargo test`<code class=\"language-text\"></code> みたいに使うとよろし。</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"rust:nameless.rs\"><pre class=\"language-rust:nameless.rs\"><code class=\"language-rust:nameless.rs\">// http://www.cis.upenn.edu/~bcpierce/tapl/checkers/untyped/\n#![allow(dead_code)]\n#![allow(unused_variables)]\n#![allow(unused_imports)]\n\nuse std::fmt::Debug;\nuse std::fmt::Formatter;\nuse std::fmt::Error;\n\n#[derive(Clone,PartialEq)]\npub enum Term {\n    // Single Varialbe\n    Var(isize, // de Bruijn Index.\n        usize), // length of Context where this variable appealed.\n    // Abstraction\n    Abst(String, // lambda variable name\n         Box&lt;Term&gt;), // lambda body\n    // Application\n    Apply(Box&lt;Term&gt;, // function\n          Box&lt;Term&gt;) // argument\n}\n\n#[derive(Debug,Clone)]\npub enum Binding {\n    NameBind\n}\n\npub type Context = Vec&lt;(String, Binding)&gt;;\n\nfn index2name(ctx: &amp;Context, idx: isize) -&gt; String {\n    if idx &gt; ctx.len() as isize-1 {\n        return format!(&quot;fv{}&quot;, idx)\n    }\n    ctx[(ctx.len() as isize-idx-1) as usize].0.to_string()\n}\n\nuse nameless::Term::*;\n\npub fn add_name(ctx:&amp;Context, name:&amp;String) -&gt; Context {\n    let mut new_ctx = ctx.clone();\n    new_ctx.push((name.clone(), Binding::NameBind));\n    new_ctx\n}\n\nfn pick_fresh_name(ctx:&amp;Context, x:&amp;String) -&gt; (Context, String) {\n    if ctx.iter().any(|&amp;(ref var_name,_)|{*var_name==*x}) {\n        //名前xがctxに存在(重複)していたら、新規名称に変更して再トライ\n        pick_fresh_name(ctx, &amp;format!(&quot;{}&#39;&quot;, x))\n    }\n    else { // 重複しない名前を得たら\n        // ctxにその名前を登録して、(ctx,その名前)を返す。\n        (add_name(ctx, x), x.clone())\n    }\n}\n\nfn print_term(ctx:&amp;Context, t:&amp;Term) -&gt; String {\n    match *t {\n        Abst(ref var_name, ref t1) =&gt; {\n            // λ var_name . t1 は、var_nameを環境ctxでユニークであるx_にした上で、\n            // x_をctxに登録しそのx_を登録したctx(ctx_)の元で、t1を表示する。\n            let (ctx_, x_) = pick_fresh_name(ctx, var_name);\n            format!(&quot;(lambda {}. {})&quot;, x_, print_term(&amp;ctx_, &amp;t1))\n        },\n        Apply(ref t1, ref t2) =&gt; {\n            format!(&quot;({} {})&quot;, print_term(ctx, &amp;t1), print_term(ctx, &amp;t2))\n        },\n        Var(x, n) =&gt; {\n            if ctx.len() == n {\n                format!(&quot;{}&quot;, index2name(ctx, x))\n            } else {\n                format!(&quot;[bad index, ctx.len={}, n={}]&quot;, ctx.len(), n).to_string()\n            }\n        }\n    }\n}\n\nimpl Debug for Term {\n    fn fmt(&amp;self, fmt:&amp;mut Formatter) -&gt; Result&lt;(), Error&gt; {\n        fmt.write_str(&amp;format!(&quot;{}&quot;, print_term(&amp;vec![], self)))\n    }\n}\n\nfn term_shift(d:isize, t:&amp;Term) -&gt; Term {\n    fn term_shift_helper(c:isize, d:isize, t:&amp;Term) -&gt; Term {\n        match *t {\n            Var(x, n) =&gt;\n                if x &gt;= c { Var(x+d, (n as isize + d) as usize) }\n                else { Var(x, (n as isize + d) as usize) },\n            Abst(ref x, ref t1) =&gt;\n                Abst(x.clone(), Box::new(term_shift_helper(c+1, d, &amp;t1))),\n            Apply(ref t1, ref t2) =&gt;\n                Apply(Box::new(term_shift_helper(c, d, t1)), Box::new(term_shift_helper(c, d, t2)))\n        }\n    }\n\n    term_shift_helper(0, d, t)\n}\n\nfn term_subst(j:isize, s:&amp;Term, t:&amp;Term) -&gt; Term {\n    fn term_subst_helper(j:isize, s:&amp;Term, c:isize, t:&amp;Term) -&gt; Term {\n        match *t {\n            Var(x, n) =&gt;\n                if x == j+c { term_shift(c, s) } else { Var(x, n) },\n            Abst(ref x, ref t1) =&gt;\n                Abst(x.clone(), Box::new(term_subst_helper(j, s, c+1, t1))),\n            Apply(ref t1, ref t2) =&gt;\n                Apply(Box::new(term_subst_helper(j, s, c, t1)), Box::new(term_subst_helper(j, s, c, t2)))\n        }\n    }\n    term_subst_helper(j, s, 0, t)\n}\n\nfn term_subst_top(s:&amp;Term, t:&amp;Term) -&gt; Term {\n    // Apply(Abst(x, t12), v2@Abst(_,_))\n    //\n    //                        -1        1\n    // (λ.t12) v2    →    ↑   ([0→↑  (v2)] t12)\n    //\n    // 「Apply(Abst(x, t12), v2@Abst(_,_))」の評価は、t12が使用して\n    // いる変数x(de Bruijn index=0)をv2で置換するということである\n    // (β簡約)。しかし、v2も(de Bruijn index 0)を参照している可能\n    // 性があるので、単なる置換はできない。そのためには、v2の(de\n    // Bruijn index 0)を(de Bruijn index 1)にする必要がある。さらに、\n    // v2はもともと(de Bruijn index 1)を使用しているかもしれないの\n    // で、0→1、1→2、2→3...というようにv2で使用している変数すべ\n    // ての玉つきでの増加が必要。これが内側のシフト操作\n    //      1\n    // 0→↑  (v2) \n    // の意味である。\n    // 上記より、無事v2から(de Bruijn index 0)を消去できたとして、\n    // λの中にあったt12を、λ取ってその外側の中で通用する値として\n    // 機能させるには、ネストレベルを一個浅くする必要がある。これが\n    // 外側の\n    //   -1\n    // ↑\n    // の操作である。これが意味するのは最内周の変数(de Bruijn\n    // index 0)の削除であり、de Bruijn index 1以上の変数をそれぞれ\n    // 1個インデックスが減るようにずらす。t12の(de Bruijn index 0)\n    // をv2で置換した結果には、(de Bruijn index 0)は(置換されている\n    // ので)もう存在していないので、これは安全に実行できる。\n    term_shift(-1, &amp;term_subst(0, &amp;term_shift(1, s), t))\n}\n\nfn is_val(t: &amp;Term) -&gt; bool {\n    match *t {\n        Abst(_,_) =&gt; true,\n        _ =&gt; false\n    }\n}\n\nfn eval1(ctx:&amp;Context, t:&amp;Term) -&gt; Option&lt;Term&gt; {\n    match t {\n        &amp;Apply(box Abst(ref x, box ref t12), ref v2) if is_val(v2) =&gt; {\n            Some(term_subst_top(v2, &amp;t12))\n        },\n        // Apply(v1@Abst(_,_), t2)\n        // (λ _._) t2\n        &amp;Apply(ref v1, ref t2) if is_val(v1) =&gt; {\n            match eval1(ctx, t2) {\n                Some(t2_) =&gt; {\n                    // (λ _._) t2_\n                    Some(Apply(v1.clone(), Box::new(t2_)))\n                },\n                None =&gt; None\n            }\n        },\n        // Apply(t1, t2)\n        &amp;Apply(ref t1, ref t2) =&gt; {\n            match eval1(ctx, &amp;t1) {\n                Some(t1_) =&gt; Some(Apply(Box::new(t1_), t2.clone())),\n                None =&gt; None\n            }\n        },\n        _ =&gt; None\n    }\n}\n\nfn eval(ctx:&amp;Context, t:&amp;Term) -&gt; Term {\n    match eval1(ctx, &amp;t) {\n        Some(x) =&gt; x.eval(),\n        None =&gt; t.clone()\n    }\n}\n\nimpl Term {\n    pub fn eval(&amp;self) -&gt; Term {\n        eval(&amp;vec![], self)\n    }\n}\n\nfn abst(s:&amp;str, t:Term) -&gt; Term {\n    Abst(s.to_string(), Box::new(t))\n}\n\nfn apply(t1:Term, t2:Term) -&gt; Term {\n    Apply(Box::new(t1), Box::new(t2))\n}</code></pre></div>\n<p>テストコードを含めたものは<a href=\"https://gist.github.com/uehaj/07a2f4856a2c51df4e1f\">こちらのgist</a>にあります。</p>","frontmatter":{"date":"January 01, 1970","path":"/https://qiita.com/uehaj/items/161f3c943faf35c6aefc/index.html","title":"TaPLのML実装をRustでやってみるシリーズ「7章 ラムダ計算のML実装」","thumbnail":null,"metaDescription":null}}},"pageContext":{}}}